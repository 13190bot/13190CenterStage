// BASE: Generated by Recorder.java
package org.firstinspires.ftc.teamcode.TeleOp.MainTeleop;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ServoImplEx;
import com.qualcomm.robotcore.util.ElapsedTime;

@Autonomous(group="Recorder", name="Replayer")
public class Replayer extends LinearOpMode {

    // NOT AUTOGEN
    // Odometry pid coefficients
    public static double o_kP = 0;
    public static double o_kI = 0;
    public static double o_kD = 0;
    public static boolean o_ClearIntegralIfNoChange = true;

    public static double o_kM = 1; // ecMotor power TESTING correcting coefficient



    // AUTOGEN
    double[][] data = {{}, {}};
    String[] motorNames = {""};
    String[] servoNames = {""};
    String[] odometryNames = {""};




    DcMotor[] motors = new DcMotor[motorNames.length];
    Servo[] servos = new Servo[servoNames.length];
    DcMotor[] odometry = new DcMotor[odometryNames.length];
    @Override
    public void runOpMode() throws InterruptedException {
        for (int i = 0; i < motorNames.length; i++) {
            motors[i] = hardwareMap.get(DcMotor.class, motorNames[i]);
        }
        for (int i = 0; i < servoNames.length; i++) {
            servos[i] = hardwareMap.get(Servo.class, servoNames[i]);
        }
        for (int i = 0; i < odometryNames.length; i++) {
            odometry[i] = hardwareMap.get(DcMotor.class, odometryNames[i]);
        }

        waitForStart();

        replay(data);
    }

    public void resetOdometry() {
        for (int i = 0; i < odometry.length; i++) {
            DcMotor motor = odometry[i];
            motor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            motor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        }
    }

    // Yields, synchronous
    public void replay(double[][] data) {
        // Reset encoders
        resetOdometry();

        ElapsedTime timer = new ElapsedTime();
        double lastError[] = new double[odometry.length];
        double integral[] = new double[odometry.length];

        long replayingStartTime = System.nanoTime();
        int i = 0;
        // Busy looping for each ms (assuming replay loop time is less than recording loop time)
        int length = data[0].length;
        while (opModeIsActive()) {
            boolean loopedAtLeastOnce = false; // TODO FOR DEBUG, REMOVE
            while ((long) data[0][i] > System.nanoTime() - replayingStartTime) {
                // Busy loop
                loopedAtLeastOnce = true; // TODO FOR DEBUG, REMOVE
            }


            // Motors
            if (i != length - 1) {
                // If needed for (more) accuracy, factor in odometry
                double powerMultiplier = 0;
                double currentT = timer.seconds();
                for (int i2 = 0; i2 < odometry.length; i2++) {
////                    double lastV = (double) data[2 + motors.length + servos.length + i2][i - 1];
//                    double currentV = data[2 + motors.length + servos.length + i2][i];
//                    double nextV = data[2 + motors.length + servos.length + i2][i + 1];
//                    double currentT = data[0][i];
//                    double nextT = data[0][i + 1];
//                    telemetry.addData("Encoder " + odometryNames[i2] + "(" + i2 + "): ", odometry[i2].getCurrentPosition());
//                    telemetry.addData("Difference (recorded - measured): ", currentV - odometry[i2].getCurrentPosition());
//                    powerMultiplier = powerMultiplier + (1 + kO * ((nextV - currentV) / (nextT - currentT) * (currentV - odometry[i2].getCurrentPosition())));

                    double currentV2 = data[2 + motors.length + servos.length + i2][i];
                    telemetry.addData("Encoder " + odometryNames[i2] + "(" + i2 + ") recorded: ", currentV2);
                    telemetry.addData("Encoder " + odometryNames[i2] + "(" + i2 + ") measured: ", odometry[i2].getCurrentPosition());
                    telemetry.addData("Difference " + i2 + " (recorded - measured): ", currentV2 - odometry[i2].getCurrentPosition());


                    double currentV = data[2 + motors.length + servos.length + i2][i];
                    double nextV = data[2 + motors.length + servos.length + i2][i + 1];
                    double error = currentV - odometry[i2].getCurrentPosition();
                    double derivative = (error - lastError[i2]) / currentT;
                    double recordedChange = nextV - currentV;
                    if (recordedChange != 0) {
                        integral[i2] = integral[i2] + (error * currentT);
                        powerMultiplier = powerMultiplier + (recordedChange > 0 ? 1 : -1) * ((o_kP * error) + (o_kI * integral[i2]) + (o_kD * derivative));
                    } else if (o_ClearIntegralIfNoChange) {
                        integral[i2] = 0;
                    }

                    lastError[i2] = error;
                }
                timer.reset();
                powerMultiplier = 1 + powerMultiplier / odometry.length;
                powerMultiplier = powerMultiplier * o_kM;
                telemetry.addData("powerMultiplier", powerMultiplier);
                for (int i2 = 0; i2 < motors.length; i2++) {
                    motors[i2].setPower(data[i2 + 2][i] * powerMultiplier);
                }

            } else {
                // Don't factor in anything (TESTED)
                for (int i2 = 0; i2 < motors.length; i2++) {
                    motors[i2].setPower(data[2 + i2][i]);
                }
            }

            // Servos
            for (int i2 = 0; i2 < servos.length; i2++) {
                double v = data[2 + motors.length + i2][i];

                if (i == 0 || (data[2 + motors.length + i2][i - 1] != v)) {
                    if (Double.isNaN(v)) {
                        ((ServoImplEx) servos[i2]).setPwmDisable();
                    } else {
                        ((ServoImplEx) servos[i2]).setPwmEnable();
                        servos[i2].setPosition(v);
                    }
                }
            }

            // Other code
            // Stop replaying
//            if (gamepad1.b) {
//                break;
//            }

            i = i + 1;
            if (i == length) {
                break;
            }



            // telemetry shit
            telemetry.addData("REPLAYING", i + "/" + length);
            telemetry.addData("KEEPING UP WITH RECORDED", loopedAtLeastOnce);
            telemetry.update();
        }
    }

}
