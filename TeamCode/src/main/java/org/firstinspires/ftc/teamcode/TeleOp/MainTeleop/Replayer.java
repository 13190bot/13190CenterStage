// BASE: Generated by Recorder.java
package org.firstinspires.ftc.teamcode.TeleOp.MainTeleop;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ServoImplEx;

@Autonomous(group="Recorder", name="Replayer")
public class Replayer extends LinearOpMode {

    // NOT AUTOGEN
    public static double kO = 0.001; // Odometry correcting coefficient


    // AUTOGEN
    double[][] data = {{}, {}};
    String[] motorNames = {""};
    String[] servoNames = {""};
    String[] odometryNames = {""};




    DcMotor[] motors = new DcMotor[motorNames.length];
    Servo[] servos = new Servo[servoNames.length];
    DcMotor[] odometry = new DcMotor[odometryNames.length];
    @Override
    public void runOpMode() throws InterruptedException {
        for (int i = 0; i < motorNames.length; i++) {
            motors[i] = hardwareMap.get(DcMotor.class, motorNames[i]);
        }
        for (int i = 0; i < servoNames.length; i++) {
            servos[i] = hardwareMap.get(Servo.class, servoNames[i]);
        }
        for (int i = 0; i < odometryNames.length; i++) {
            odometry[i] = hardwareMap.get(DcMotor.class, odometryNames[i]);
        }

        waitForStart();

        replay(data);
    }

    public void resetOdometry() {
        for (int i = 0; i < odometry.length; i++) {
            DcMotor motor = odometry[i];
            motor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
            motor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
        }
    }

    // Yields, synchronous
    public void replay(double[][] data) {
        // Reset encoders
        resetOdometry();

        long replayingStartTime = System.nanoTime();
        int i = 0;
        // Busy looping for each ms (assuming replay loop time is less than recording loop time)
        int length = data[0].length;
        while (opModeIsActive()) {
            boolean loopedAtLeastOnce = false; // TODO FOR DEBUG, REMOVE
            while ((long) data[0][i] > System.nanoTime() - replayingStartTime) {
                // Busy loop
                loopedAtLeastOnce = true; // TODO FOR DEBUG, REMOVE
            }


            // Motors

            // DOESN'T WORK
            // If needed for (more) accuracy, factor in voltage difference (UNTESTED)
//            double startVoltage = voltageSensor.getVoltage();
//            double powerMultiplier = (double) data[1][i] / startVoltage; // assumes linear model
//            for (int i2 = 0; i2 < motors.length; i2++) {
//                motors[i2].setPower((double) data[i2 + 2][i] * powerMultiplier);
//
//                telemetry.addData("a", (double) data[i2 + 2][i] * powerMultiplier);
//            }



            if (i != length - 1) {
                // If needed for (more) accuracy, factor in odometry
                double powerMultiplier = 0;
                for (int i2 = 0; i2 < odometry.length; i2++) {
//                    double lastV = (double) data[2 + motors.length + servos.length + i2][i - 1];
                    double currentV = data[2 + motors.length + servos.length + i2][i];
                    double nextV = data[2 + motors.length + servos.length + i2][i + 1];
                    double currentT = data[0][i];
                    double nextT = data[0][i + 1];
                    telemetry.addLine("Encoder " + odometryNames[i2] + "(" + i2 + ")");
                    telemetry.addData("Difference (recorded - measured): ", currentV - odometry[i2].getCurrentPosition());
                    powerMultiplier = powerMultiplier + (1 + kO * ((nextV - currentV) / (nextT - currentT) * (currentV - odometry[i2].getCurrentPosition())));
                }
                powerMultiplier = powerMultiplier / odometry.length;
                telemetry.addData("powerMultiplier", powerMultiplier);
                for (int i2 = 0; i2 < motors.length; i2++) {
                    motors[i2].setPower(data[i2 + 2][i] * powerMultiplier);
                }

            } else {
                // Don't factor in anything (TESTED)
                for (int i2 = 0; i2 < motors.length; i2++) {
                    motors[i2].setPower(data[2 + i2][i]);
                }
            }

            // Servos
            for (int i2 = 0; i2 < servos.length; i2++) {
                double v = data[2 + motors.length + i2][i];

                if (i == 0 || (data[2 + motors.length + i2][i - 1] != v)) {
                    if (Double.isNaN(v)) {
                        ((ServoImplEx) servos[i2]).setPwmDisable();
                    } else {
                        ((ServoImplEx) servos[i2]).setPwmEnable();
                        servos[i2].setPosition(v);
                    }
                }
            }

            // Other code
            // Stop replaying
//            if (gamepad1.b) {
//                break;
//            }

            i = i + 1;
            if (i == length) {
                break;
            }



            // telemetry shit
            telemetry.addData("REPLAYING", i + "/" + length);
            telemetry.addData("KEEPING UP WITH RECORDED", loopedAtLeastOnce);
            telemetry.update();
        }
    }

}
